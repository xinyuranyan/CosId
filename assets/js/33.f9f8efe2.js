(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{455:function(t,_,e){"use strict";e.r(_);var v=e(17),r=Object(v.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"性能对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能对比"}},[t._v("#")]),t._v(" 性能对比")]),t._v(" "),e("p",[t._v("TODO")]),t._v(" "),e("h2",{attrs:{id:"分布式id方案的核心指标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式id方案的核心指标"}},[t._v("#")]),t._v(" 分布式ID方案的核心指标")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("全局（相同业务）唯一性")]),t._v("：唯一性保证是"),e("strong",[t._v("ID")]),t._v("的必要条件，假设ID不唯一就会产生主键冲突，这点很容易可以理解。\n"),e("ul",[e("li",[t._v("通常所说的全局唯一性并不是指所有业务服务都要唯一，而是相同业务服务不同部署副本唯一。\n比如 Order 服务的多个部署副本在生成"),e("code",[t._v("t_order")]),t._v("这张表的"),e("code",[t._v("Id")]),t._v("时是要求全局唯一的。至于"),e("code",[t._v("t_order_item")]),t._v("生成的"),e("code",[t._v("ID")]),t._v("与"),e("code",[t._v("t_order")]),t._v("是否唯一，并不影响唯一性约束，也不会产生什么副作用。\n不同业务模块间也是同理。即唯一性主要解决的是ID冲突问题。")])])]),t._v(" "),e("li",[e("strong",[t._v("有序性")]),t._v("：有序性保证是面向查询的数据结构算法（除了Hash算法）所必须的，是"),e("strong",[t._v("二分查找法")]),t._v("(分而治之)的前提。\n"),e("ul",[e("li",[t._v("MySq-InnoDB B+树是使用最为广泛的，假设 Id 是无序的，B+ 树 为了维护 ID 的有序性，就会频繁的在索引的中间位置插入而挪动后面节点的位置，甚至导致频繁的页分裂，这对于性能的影响是极大的。那么如果我们能够保证ID的有序性这种情况就完全不同了，只需要进行追加写操作。所以 ID 的有序性是非常重要的，也是ID设计不可避免的特性。")])])]),t._v(" "),e("li",[e("strong",[t._v("吞吐量/性能(ops/time)")]),t._v("：即单位时间（每秒）能产生的ID数量。生成ID是非常高频的操作，也是最为基本的。假设ID生成的性能缓慢，那么不管怎么进行系统优化也无法获得更好的性能。\n"),e("ul",[e("li",[t._v("一般我们会首先生成ID，然后再执行写入操作，假设ID生成缓慢，那么整体性能上限就会受到限制，这一点应该不难理解。")])])]),t._v(" "),e("li",[e("strong",[t._v("稳定性(time/op)")]),t._v("：稳定性指标一般可以采用"),e("strong",[t._v("每个操作的时间进行百分位采样")]),t._v("来分析，比如 "),e("em",[e("a",{attrs:{href:"https://github.com/Ahoo-Wang/CosId",target:"_blank",rel:"noopener noreferrer"}},[t._v("CosId"),e("OutboundLink")],1)]),t._v(" 百分位采样 "),e("strong",[t._v("P9999=0.208 us/op")]),t._v("，即 "),e("strong",[t._v("0% ~ 99.99%")]),t._v(" 的单位操作时间小于等于  "),e("strong",[t._v("0.208 us/op")]),t._v("。\n"),e("ul",[e("li",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0",target:"_blank",rel:"noopener noreferrer"}},[t._v("百分位数 WIKI"),e("OutboundLink")],1),t._v(" ：统计学术语，若将一组数据从小到大排序，并计算相应的累计百分点，则某百分点所对应数据的值，就称为这百分点的百分位数，以Pk表示第k百分位数。百分位数是用来比较个体在群体中的相对地位量数。")]),t._v(" "),e("li",[t._v("为什么不用平均"),e("em",[t._v("每个操作的时间")]),t._v("：马老师的身价跟你的身价能平均么？平均后的值有意义不？")]),t._v(" "),e("li",[t._v("可以使用最小"),e("em",[t._v("每个操作的时间")]),t._v("、最大"),e("em",[t._v("每个操作的时间")]),t._v("作为参考吗？因为最小、最大值只说明了零界点的情况，虽说可以作为稳定性的参考，但依然不够全面。而且"),e("em",[t._v("百分位数")]),t._v("已经覆盖了这俩个指标。")])])]),t._v(" "),e("li",[e("strong",[t._v("自治性（依赖）")]),t._v("：主要是指对外部环境有无依赖，比如"),e("strong",[t._v("号段模式")]),t._v("会强依赖第三方存储中间件来获取"),e("code",[t._v("NexMaxId")]),t._v("。自治性还会对可用性造成影响。")]),t._v(" "),e("li",[e("strong",[t._v("可用性")]),t._v("：分布式ID的可用性主要会受到自治性影响，比如"),e("strong",[t._v("SnowflakeId")]),t._v("会受到时钟回拨影响，导致处于短暂时间的不可用状态。而"),e("strong",[t._v("号段模式")]),t._v("会受到第三方发号器（"),e("code",[t._v("NexMaxId")]),t._v("）的可用性影响。\n"),e("ul",[e("li",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%94%A8%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[t._v("可用性 WIKI"),e("OutboundLink")],1),t._v(" ：在一个给定的时间间隔内，对于一个功能个体来讲，总的可用时间所占的比例。")]),t._v(" "),e("li",[t._v("MTBF：平均故障间隔")]),t._v(" "),e("li",[t._v("MDT：平均修复/恢复时间")]),t._v(" "),e("li",[t._v("Availability=MTBF/(MTBF+MDT)")]),t._v(" "),e("li",[t._v("假设MTBF为1年，MDT为1小时，即"),e("code",[t._v("Availability=(365*24)/(365*24+1)=0.999885857778792≈99.99%")]),t._v("，也就是我们通常所说对可用性4个9。")])])]),t._v(" "),e("li",[e("strong",[t._v("适应性")]),t._v("：是指在面对外部环境变化的自适应能力，这里我们主要说的是面对流量突发时动态伸缩分布式ID的性能，\n"),e("ul",[e("li",[e("strong",[t._v("SegmentChainId")]),t._v("可以基于"),e("strong",[t._v("饥饿状态")]),t._v("进行"),e("strong",[t._v("安全距离")]),t._v("的动态伸缩。")]),t._v(" "),e("li",[e("strong",[t._v("SnowflakeId")]),t._v("常规位分配方案性能恒定409.6W，虽然可以通过调整位分配方案来获得不同的TPS性能，但是位分配方法的变更是破坏性的，一般根据业务场景确定位分配方案后不再变更。")])])]),t._v(" "),e("li",[e("strong",[t._v("存储空间")]),t._v("：还是用MySq-InnoDB B+树来举例，普通索引（二级索引）会存储主键值，主键越大占用的内存缓存、磁盘空间也会越大。Page页存储的数据越少，磁盘IO访问的次数会增加。总之在满足业务需求的情况下，尽可能小的存储空间占用在绝大多数场景下都是好的设计原则。")])]),t._v(" "),e("h2",{attrs:{id:"分布式id的核心算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式id的核心算法"}},[t._v("#")]),t._v(" 分布式ID的核心算法")]),t._v(" "),e("h2",{attrs:{id:"按位分区算法-snowflakeid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按位分区算法-snowflakeid"}},[t._v("#")]),t._v(" 按位分区算法 ("),e("code",[t._v("SnowflakeId")]),t._v(")")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",{staticStyle:{"text-align":"right"}},[t._v("性能（吞吐量）")]),t._v(" "),e("th",{staticStyle:{"text-align":"right"}},[t._v("稳定性（百分位数）")]),t._v(" "),e("th",[t._v("自治性（依赖）")]),t._v(" "),e("th",[t._v("机器号分配器")]),t._v(" "),e("th",[t._v("机器号回收")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("使用方式")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/Ahoo-Wang/CosId",target:"_blank",rel:"noopener noreferrer"}},[t._v("CosId"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("4,096,000(ops/s)")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("P9999=0.244(us/op)")]),t._v(" "),e("td",[t._v("首次启动，依赖"),e("strong",[t._v("机器号分配器")])]),t._v(" "),e("td",[t._v("手动分配器、K8S、关系型数据库、Redis、ZooKeeper")]),t._v(" "),e("td",[t._v("支持")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("SDK(推荐)/RPC/RESTful")])]),t._v(" "),e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/Meituan-Dianping/Leaf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Leaf"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td"),t._v(" "),e("td",[t._v("ZooKeeper")]),t._v(" "),e("td"),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/baidu/uid-generator",target:"_blank",rel:"noopener noreferrer"}},[t._v("uid-generator"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td"),t._v(" "),e("td",[t._v("关系型数据库")]),t._v(" "),e("td"),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/didi/tinyid",target:"_blank",rel:"noopener noreferrer"}},[t._v("TinyID"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("不支持"),e("strong",[t._v("按位分区算法")])]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td",{staticStyle:{"text-align":"left"}})])])]),t._v(" "),e("h2",{attrs:{id:"号段算法-segmentid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#号段算法-segmentid"}},[t._v("#")]),t._v(" 号段算法 ("),e("code",[t._v("SegmentId")]),t._v(")")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",{staticStyle:{"text-align":"right"}},[t._v("性能（吞吐量）")]),t._v(" "),e("th",{staticStyle:{"text-align":"right"}},[t._v("稳定性（百分位数）")]),t._v(" "),e("th",[t._v("自治性（依赖）")]),t._v(" "),e("th",[t._v("号段分发器")]),t._v(" "),e("th",[t._v("适应性")]),t._v(" "),e("th",[t._v("存储空间")]),t._v(" "),e("th",[t._v("使用方式")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/Ahoo-Wang/CosId",target:"_blank",rel:"noopener noreferrer"}},[t._v("CosId"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("127,439,148(ops/s)")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("P9999=0.208(us/op)")]),t._v(" "),e("td",[t._v("依赖"),e("strong",[t._v("号段分发器")])]),t._v(" "),e("td",[t._v("关系型数据库、Redis、ZooKeeper")]),t._v(" "),e("td",[t._v("支持"),e("code",[t._v("Step")]),t._v("自动扩缩容")]),t._v(" "),e("td",[t._v("64-bit")]),t._v(" "),e("td",[t._v("SDK(推荐)/RPC/RESTful")])]),t._v(" "),e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/Meituan-Dianping/Leaf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Leaf"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td"),t._v(" "),e("td",[t._v("MySql")]),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td")]),t._v(" "),e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/baidu/uid-generator",target:"_blank",rel:"noopener noreferrer"}},[t._v("uid-generator"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("不支持"),e("strong",[t._v("号段算法")])]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td")]),t._v(" "),e("tr",[e("td",[e("a",{attrs:{href:"https://github.com/didi/tinyid",target:"_blank",rel:"noopener noreferrer"}},[t._v("TinyID"),e("OutboundLink")],1)]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td",{staticStyle:{"text-align":"right"}}),t._v(" "),e("td"),t._v(" "),e("td",[t._v("数据库")]),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);