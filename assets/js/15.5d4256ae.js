(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{437:function(t,e,_){"use strict";_.r(e);var v=_(17),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.apache.org/licenses/LICENSE-2.0.html",target:"_blank",rel:"noopener noreferrer"}},[_("img",{attrs:{src:"https://img.shields.io/badge/license-Apache%202-4EB1BA.svg",alt:"License"}}),_("OutboundLink")],1),t._v(" "),_("a",{attrs:{href:"https://github.com/Ahoo-Wang/CosId/releases",target:"_blank",rel:"noopener noreferrer"}},[_("img",{attrs:{src:"https://img.shields.io/github/release/Ahoo-Wang/CosId.svg",alt:"GitHub release"}}),_("OutboundLink")],1),t._v(" "),_("a",{attrs:{href:"https://app.codacy.com/gh/Ahoo-Wang/CosId?utm_source=github.com&utm_medium=referral&utm_content=Ahoo-Wang/CosId&utm_campaign=Badge_Grade_Settings",target:"_blank",rel:"noopener noreferrer"}},[_("img",{attrs:{src:"https://api.codacy.com/project/badge/Grade/dfd1d6237a1644409548ebfbca300dc1",alt:"Codacy Badge"}}),_("OutboundLink")],1)]),t._v(" "),_("p",{attrs:{align:"center"}},[_("img",{attrs:{width:"200",src:t.$withBase("/logo.png"),alt:"Throughput-Of-SegmentChainId"}})]),t._v(" "),_("p",[_("em",[_("a",{attrs:{href:"https://github.com/Ahoo-Wang/CosId",target:"_blank",rel:"noopener noreferrer"}},[t._v("CosId"),_("OutboundLink")],1)]),t._v(" 旨在提供通用、灵活、高性能的分布式 ID 生成器。")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("SnowflakeId")]),t._v(" : "),_("em",[t._v("单机 TPS 性能：409W/s")]),t._v(" "),_("RouterLink",{attrs:{to:"/guide/perf-test.html"}},[t._v("JMH 基准测试")]),t._v(" , 主要解决 "),_("em",[t._v("时钟回拨问题")]),t._v(" 、"),_("em",[t._v("机器号分配问题")]),t._v(" 并且提供更加友好、灵活的使用体验。")],1),t._v(" "),_("li",[_("code",[t._v("SegmentId")]),t._v(": 每次获取一段 ("),_("code",[t._v("Step")]),t._v(") ID，来降低号段分发器的网络IO请求频次提升性能。\n"),_("ul",[_("li",[_("code",[t._v("IdSegmentDistributor")]),t._v(": 号段分发器（号段存储器）\n"),_("ul",[_("li",[_("code",[t._v("RedisIdSegmentDistributor")]),t._v(": 基于 "),_("em",[t._v("Redis")]),t._v(" 的号段分发器。")]),t._v(" "),_("li",[_("code",[t._v("JdbcIdSegmentDistributor")]),t._v(": 基于 "),_("em",[t._v("Jdbc")]),t._v(" 的号段分发器，支持各种关系型数据库。")])])]),t._v(" "),_("li",[_("code",[t._v("SegmentChainId")]),t._v("("),_("strong",[t._v("推荐")]),t._v("):"),_("code",[t._v("SegmentChainId")]),t._v(" ("),_("em",[t._v("lock-free")]),t._v(") 是对 "),_("code",[t._v("SegmentId")]),t._v(" 的增强。性能可达到近似 "),_("code",[t._v("AtomicLong")]),t._v(" 的 "),_("em",[t._v("TPS 性能:12743W+/s")]),t._v(" "),_("RouterLink",{attrs:{to:"/guide/perf-test.html"}},[t._v("JMH 基准测试")]),t._v(" 。\n"),_("ul",[_("li",[_("code",[t._v("PrefetchWorker")]),t._v(" 维护安全距离("),_("code",[t._v("safeDistance")]),t._v("), 并且支持基于饥饿状态的动态"),_("code",[t._v("safeDistance")]),t._v("扩容/收缩。")])])],1)])])]),t._v(" "),_("h2",{attrs:{id:"背景-为什么需要分布式id"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#背景-为什么需要分布式id"}},[t._v("#")]),t._v(" 背景（为什么需要"),_("em",[t._v("分布式ID")]),t._v("）")]),t._v(" "),_("p",[t._v("在软件系统演进过程中，随着业务规模的增长，我们需要进行集群化部署来分摊计算、存储压力，应用服务我们可以很轻松做到无状态、弹性伸缩。\n但是仅仅增加服务副本数就够了吗？显然不够，因为性能瓶颈往往是在数据库层面，那么这个时候我们就需要考虑如何进行数据库的扩容、伸缩、集群化，通常使用分库、分表的方式来处理。\n那么我如何分片(水平分片，当然还有垂直分片不过不是本文需要讨论的内容)呢，分片得前提是我们得先有一个ID，然后才能根据分片算法来分片。（比如比较简单常用的ID取模分片算法，这个跟Hash算法的概念类似，我们得先有key才能进行Hash取得插入槽位。）")]),t._v(" "),_("blockquote",[_("p",[t._v("当然还有很多分布式场景需要"),_("em",[t._v("分布式ID")]),t._v("，这里不再一一列举。")])]),t._v(" "),_("h2",{attrs:{id:"分布式id方案的核心指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式id方案的核心指标"}},[t._v("#")]),t._v(" 分布式ID方案的核心指标")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("全局（相同业务）唯一性")]),t._v("：唯一性保证是"),_("strong",[t._v("ID")]),t._v("的必要条件，假设ID不唯一就会产生主键冲突，这点很容易可以理解。\n"),_("ul",[_("li",[t._v("通常所说的全局唯一性并不是指所有业务服务都要唯一，而是相同业务服务不同部署副本唯一。\n比如 Order 服务的多个部署副本在生成"),_("code",[t._v("t_order")]),t._v("这张表的"),_("code",[t._v("Id")]),t._v("时是要求全局唯一的。至于"),_("code",[t._v("t_order_item")]),t._v("生成的"),_("code",[t._v("ID")]),t._v("与"),_("code",[t._v("t_order")]),t._v("是否唯一，并不影响唯一性约束，也不会产生什么副作用。\n不同业务模块间也是同理。即唯一性主要解决的是ID冲突问题。")])])]),t._v(" "),_("li",[_("strong",[t._v("有序性")]),t._v("：有序性保证是面向查询的数据结构算法（除了Hash算法）所必须的，是"),_("strong",[t._v("二分查找法")]),t._v("(分而治之)的前提。\n"),_("ul",[_("li",[t._v("MySq-InnoDB B+树是使用最为广泛的，假设 Id 是无序的，B+ 树 为了维护 ID 的有序性，就会频繁的在索引的中间位置插入而挪动后面节点的位置，甚至导致频繁的页分裂，这对于性能的影响是极大的。那么如果我们能够保证ID的有序性这种情况就完全不同了，只需要进行追加写操作。所以 ID 的有序性是非常重要的，也是ID设计不可避免的特性。")])])]),t._v(" "),_("li",[_("strong",[t._v("吞吐量/性能(ops/time)")]),t._v("：即单位时间（每秒）能产生的ID数量。生成ID是非常高频的操作，也是最为基本的。假设ID生成的性能缓慢，那么不管怎么进行系统优化也无法获得更好的性能。\n"),_("ul",[_("li",[t._v("一般我们会首先生成ID，然后再执行写入操作，假设ID生成缓慢，那么整体性能上限就会受到限制，这一点应该不难理解。")])])]),t._v(" "),_("li",[_("strong",[t._v("稳定性(time/op)")]),t._v("：稳定性指标一般可以采用"),_("strong",[t._v("每个操作的时间进行百分位采样")]),t._v("来分析，比如 "),_("em",[_("a",{attrs:{href:"https://github.com/Ahoo-Wang/CosId",target:"_blank",rel:"noopener noreferrer"}},[t._v("CosId"),_("OutboundLink")],1)]),t._v(" 百分位采样 "),_("strong",[t._v("P9999=0.208 us/op")]),t._v("，即 "),_("strong",[t._v("0% ~ 99.99%")]),t._v(" 的单位操作时间小于等于  "),_("strong",[t._v("0.208 us/op")]),t._v("。\n"),_("ul",[_("li",[_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0",target:"_blank",rel:"noopener noreferrer"}},[t._v("百分位数 WIKI"),_("OutboundLink")],1),t._v(" ：统计学术语，若将一组数据从小到大排序，并计算相应的累计百分点，则某百分点所对应数据的值，就称为这百分点的百分位数，以Pk表示第k百分位数。百分位数是用来比较个体在群体中的相对地位量数。")]),t._v(" "),_("li",[t._v("为什么不用平均"),_("em",[t._v("每个操作的时间")]),t._v("：马老师的身价跟你的身价能平均么？平均后的值有意义不？")]),t._v(" "),_("li",[t._v("可以使用最小"),_("em",[t._v("每个操作的时间")]),t._v("、最大"),_("em",[t._v("每个操作的时间")]),t._v("作为参考吗？因为最小、最大值只说明了零界点的情况，虽说可以作为稳定性的参考，但依然不够全面。而且"),_("em",[t._v("百分位数")]),t._v("已经覆盖了这俩个指标。")])])]),t._v(" "),_("li",[_("strong",[t._v("自治性（依赖）")]),t._v("：主要是指对外部环境有无依赖，比如"),_("strong",[t._v("号段模式")]),t._v("会强依赖第三方存储中间件来获取"),_("code",[t._v("NexMaxId")]),t._v("。自治性还会对可用性造成影响。")]),t._v(" "),_("li",[_("strong",[t._v("可用性")]),t._v("：分布式ID的可用性主要会受到自治性影响，比如"),_("strong",[t._v("SnowflakeId")]),t._v("会受到时钟回拨影响，导致处于短暂时间的不可用状态。而"),_("strong",[t._v("号段模式")]),t._v("会受到第三方发号器（"),_("code",[t._v("NexMaxId")]),t._v("）的可用性影响。\n"),_("ul",[_("li",[_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%94%A8%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[t._v("可用性 WIKI"),_("OutboundLink")],1),t._v(" ：在一个给定的时间间隔内，对于一个功能个体来讲，总的可用时间所占的比例。")]),t._v(" "),_("li",[t._v("MTBF：平均故障间隔")]),t._v(" "),_("li",[t._v("MDT：平均修复/恢复时间")]),t._v(" "),_("li",[t._v("Availability=MTBF/(MTBF+MDT)")]),t._v(" "),_("li",[t._v("假设MTBF为1年，MDT为1小时，即"),_("code",[t._v("Availability=(365*24)/(365*24+1)=0.999885857778792≈99.99%")]),t._v("，也就是我们通常所说对可用性4个9。")])])]),t._v(" "),_("li",[_("strong",[t._v("适应性")]),t._v("：是指在面对外部环境变化的自适应能力，这里我们主要说的是面对流量突发时动态伸缩分布式ID的性能，\n"),_("ul",[_("li",[_("strong",[t._v("SegmentChainId")]),t._v("可以基于"),_("strong",[t._v("饥饿状态")]),t._v("进行"),_("strong",[t._v("安全距离")]),t._v("的动态伸缩。")]),t._v(" "),_("li",[_("strong",[t._v("SnowflakeId")]),t._v("常规位分配方案性能恒定409.6W，虽然可以通过调整位分配方案来获得不同的TPS性能，但是位分配方法的变更是破坏性的，一般根据业务场景确定位分配方案后不再变更。")])])]),t._v(" "),_("li",[_("strong",[t._v("存储空间")]),t._v("：还是用MySq-InnoDB B+树来举例，普通索引（二级索引）会存储主键值，主键越大占用的内存缓存、磁盘空间也会越大。Page页存储的数据越少，磁盘IO访问的次数会增加。总之在满足业务需求的情况下，尽可能小的存储空间占用在绝大多数场景下都是好的设计原则。")])]),t._v(" "),_("h3",{attrs:{id:"不同分布式id方案核心指标对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同分布式id方案核心指标对比"}},[t._v("#")]),t._v(" 不同分布式ID方案核心指标对比")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("分布式ID")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("全局唯一性")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("有序性")]),t._v(" "),_("th",{staticStyle:{"text-align":"right"}},[t._v("吞吐量")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("稳定性（1s=1000,000us）")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("自治性")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("可用性")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("适应性")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("存储空间")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("UUID/GUID")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("完全无序")]),t._v(" "),_("td",{staticStyle:{"text-align":"right"}},[t._v("3078638(ops/s)")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("P9999=0.325(us/op)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("完全自治")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("100%")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("128-bit")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("SnowflakeId")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("本地单调递增，全局趋势递增(受全局时钟影响)")]),t._v(" "),_("td",{staticStyle:{"text-align":"right"}},[t._v("4096000(ops/s)")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("P9999=0.244(us/op)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("依赖时钟")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("时钟回拨会导致短暂不可用")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("64-bit")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("SegmentId")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("本地单调递增，全局趋势递增(受Step影响)")]),t._v(" "),_("td",{staticStyle:{"text-align":"right"}},[t._v("29506073(ops/s)")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("P9999=46.624(us/op)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("依赖第三方号段分发器")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("受号段分发器可用性影响")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("64-bit")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("SegmentChainId")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("本地单调递增，全局趋势递增(受Step、安全距离影响)")]),t._v(" "),_("td",{staticStyle:{"text-align":"right"}},[t._v("127439148(ops/s)")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("P9999=0.208(us/op)")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("依赖第三方号段分发器")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("受号段分发器可用性影响，但因安全距离存在，预留ID段，所以高于SegmentId")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("64-bit")])])])]),t._v(" "),_("h3",{attrs:{id:"有序性-要想分而治之·二分查找法-必须要维护我"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有序性-要想分而治之·二分查找法-必须要维护我"}},[t._v("#")]),t._v(" 有序性(要想分而治之·二分查找法，必须要维护我)")]),t._v(" "),_("p",[t._v("刚刚我们已经讨论了ID有序性的重要性，所以我们设计ID算法时应该尽可能地让ID是单调递增的，比如像表的自增主键那样。但是很遗憾，因全局时钟、性能等分布式系统问题，我们通常只能选择局部单调递增、全局趋势递增的组合（就像我们在分布式系统中不得不的选择最终一致性那样）以获得多方面的权衡。下面我们来看一下什么是单调递增与趋势递增。")]),t._v(" "),_("h4",{attrs:{id:"有序性之单调递增"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有序性之单调递增"}},[t._v("#")]),t._v(" 有序性之单调递增")]),t._v(" "),_("p",{attrs:{align:"center"}},[_("img",{attrs:{src:t.$withBase("/assets/design/monotonically-increasing.png"),alt:"单调递增"}})]),t._v(" "),_("p",[t._v("单调递增：T表示全局绝对时点，假设有T"),_("sub",[t._v("n+1")]),t._v(">T"),_("sub",[t._v("n")]),t._v("（绝对时间总是往前进的，这里不考虑相对论、时间机器等），那么必然有F(T"),_("sub",[t._v("n+1")]),t._v(")>F(T"),_("sub",[t._v("n")]),t._v(")，数据库自增主键就属于这一类。\n另外需要特别说明的是单调递增跟连续性递增是不同的概念。 连续性递增："),_("code",[t._v("F(n+1)=(F(n)+step)")]),t._v("即下一次获取的ID一定等于当前"),_("code",[t._v("ID+Step")]),t._v("，当"),_("code",[t._v("Step=1")]),t._v("时类似于这样一个序列:"),_("code",[t._v("1->2->3->4->5")]),t._v("。")]),t._v(" "),_("blockquote",[_("p",[t._v("扩展小知识：数据库的自增主键也不是连续性递增的，相信你一定遇到过这种情况，请思考一下数据库为什么这样设计？")])]),t._v(" "),_("h4",{attrs:{id:"有序性之趋势递增"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有序性之趋势递增"}},[t._v("#")]),t._v(" 有序性之趋势递增")]),t._v(" "),_("p",{attrs:{align:"center"}},[_("img",{attrs:{src:t.$withBase("/assets/design/trend-increasing.png"),alt:"趋势递增"}})]),t._v(" "),_("p",[t._v("趋势递增：T"),_("sub",[t._v("n")]),t._v(">T"),_("sub",[t._v("n-s")]),t._v("，那么大概率有F(T"),_("sub",[t._v("n")]),t._v(")>F(T"),_("sub",[t._v("n-s")]),t._v(")。虽然在一段时间间隔内有乱序，但是整体趋势是递增。从上图上看，是有上升趋势的（趋势线）。")]),t._v(" "),_("ul",[_("li",[t._v("在"),_("strong",[t._v("SnowflakeId")]),t._v("中"),_("sub",[t._v("n-s")]),t._v("受到全局时钟同步影响。")]),t._v(" "),_("li",[t._v("在号段模式("),_("strong",[t._v("SegmentId")]),t._v(")中"),_("sub",[t._v("n-s")]),t._v("受到号段可用区间("),_("code",[t._v("Step")]),t._v(")影响。")])]),t._v(" "),_("h2",{attrs:{id:"分布式id分配方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式id分配方案"}},[t._v("#")]),t._v(" 分布式ID分配方案")]),t._v(" "),_("h3",{attrs:{id:"uuid-guid"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#uuid-guid"}},[t._v("#")]),t._v(" UUID/GUID")]),t._v(" "),_("ul",[_("li",[t._v("👍不依赖任何第三方中间件")]),t._v(" "),_("li",[t._v("👍性能高")]),t._v(" "),_("li",[t._v("👎完全无序")]),t._v(" "),_("li",[t._v("👎空间占用大，需要占用128位存储空间。")])]),t._v(" "),_("p",[t._v("UUID最大的缺陷是随机的、无序的，当用于主键时会导致数据库的主键索引效率低下（为了维护索引树，频繁的索引中间位置插入数据，而不是追加写）。这也是UUID不适用于数据库主键的最为重要的原因。")]),t._v(" "),_("h3",{attrs:{id:"snowflakeid"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#snowflakeid"}},[t._v("#")]),t._v(" SnowflakeId")]),t._v(" "),_("p",{attrs:{align:"center"}},[_("img",{attrs:{src:t.$withBase("/assets/design/Snowflake-identifier.png"),alt:"SnowflakeId"}})]),t._v(" "),_("blockquote",[_("p",[_("em",[t._v("SnowflakeId")]),t._v("使用"),_("code",[t._v("Long")]),t._v("（64-bit）位分区来生成ID的一种分布式ID算法。\n通用的位分配方案为："),_("code",[t._v("timestamp")]),t._v("(41-bit)+"),_("code",[t._v("machineId")]),t._v("(10-bit)+"),_("code",[t._v("sequence")]),t._v("(12-bit)=63-bit。")])]),t._v(" "),_("ul",[_("li",[t._v("41-bit"),_("code",[t._v("timestamp")]),t._v("=(1L<<41)/(1000/3600/365)，约可以存储69年的时间戳，即可以使用的绝对时间为"),_("code",[t._v("EPOCH")]),t._v("+69年，一般我们需要自定义"),_("code",[t._v("EPOCH")]),t._v("为产品开发时间，另外还可以通过压缩其他区域的分配位数，来增加时间戳位数来延长可用时间。")]),t._v(" "),_("li",[t._v("10-bit"),_("code",[t._v("machineId")]),t._v("=(1L<<10)=1024，即相同业务可以部署1024个副本(在Kubernetes概念里没有主从副本之分，这里直接沿用Kubernetes的定义)。一般情况下没有必要使用这么多位，所以会根据部署规模需要重新定义。")]),t._v(" "),_("li",[t._v("12-bit"),_("code",[t._v("sequence")]),t._v("=(1L<<12)*1000=4096000，即单机每秒可生成约409W的ID，全局同业务集群可产生"),_("code",[t._v("4096000*1024=419430W=41.9亿(TPS)")]),t._v("。")])]),t._v(" "),_("p",[t._v("从 "),_("em",[t._v("SnowflakeId")]),t._v(" 设计上可以看出:")]),t._v(" "),_("ul",[_("li",[t._v("👍"),_("code",[t._v("timestamp")]),t._v("在高位，单实例"),_("em",[t._v("SnowflakeId")]),t._v("是会保证时钟总是向前的（校验本机时钟回拨），所以是本机单调递增的。受全局时钟同步/时钟回拨影响"),_("em",[t._v("SnowflakeId")]),t._v("是全局趋势递增的。")]),t._v(" "),_("li",[t._v("👍"),_("em",[t._v("SnowflakeId")]),t._v("不对任何第三方中间件有强依赖关系，并且性能也非常高。")]),t._v(" "),_("li",[t._v("👍位分配方案可以按照业务系统需要灵活配置，来达到最优使用效果。")]),t._v(" "),_("li",[t._v("👎强依赖本机时钟，潜在的时钟回拨问题会导致ID重复、处于短暂的不可用状态。")]),t._v(" "),_("li",[t._v("👎"),_("code",[t._v("machineId")]),t._v("需要手动设置，实际部署时如果采用手动分配"),_("code",[t._v("machineId")]),t._v("，会非常低效。")])]),t._v(" "),_("h4",{attrs:{id:"snowflakeid之机器号分配问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#snowflakeid之机器号分配问题"}},[t._v("#")]),t._v(" SnowflakeId之机器号分配问题")]),t._v(" "),_("p",[t._v("在"),_("strong",[t._v("SnowflakeId")]),t._v("中根据业务设计的位分配方案确定了基本上就不再有变更了，也很少需要维护。但是"),_("code",[t._v("machineId")]),t._v("总是需要配置的，而且集群中是不能重复的，否则分区原则就会被破坏而导致ID唯一性原则破坏，当集群规模较大时"),_("code",[t._v("machineId")]),t._v("的维护工作是非常繁琐，低效的。")]),t._v(" "),_("blockquote",[_("p",[t._v("有一点需要特别说明的，"),_("strong",[t._v("SnowflakeId")]),t._v("的"),_("strong",[t._v("MachineId")]),t._v("是逻辑上的概念，而不是物理概念。\n想象一下假设"),_("strong",[t._v("MachineId")]),t._v("是物理上的，那么意味着一台机器拥有只能拥有一个"),_("strong",[t._v("MachineId")]),t._v("，那会产生什么问题呢？")])]),t._v(" "),_("blockquote",[_("p",[t._v("目前 "),_("em",[_("a",{attrs:{href:"https://github.com/Ahoo-Wang/CosId",target:"_blank",rel:"noopener noreferrer"}},[t._v("CosId"),_("OutboundLink")],1)]),t._v(" 提供了以下三种 "),_("code",[t._v("MachineId")]),t._v(" 分配器。")])]),t._v(" "),_("ul",[_("li",[t._v("ManualMachineIdDistributor: 手动配置"),_("code",[t._v("machineId")]),t._v("，一般只有在集群规模非常小的时候才有可能使用，不推荐。")]),t._v(" "),_("li",[t._v("StatefulSetMachineIdDistributor: 使用"),_("code",[t._v("Kubernetes")]),t._v("的"),_("code",[t._v("StatefulSet")]),t._v("提供的稳定的标识ID（HOSTNAME=service-01）作为机器号。")]),t._v(" "),_("li",[t._v("RedisMachineIdDistributor: 使用"),_("strong",[t._v("Redis")]),t._v("作为机器号的分发存储，同时还会存储"),_("code",[t._v("MachineId")]),t._v("的上一次时间戳，用于"),_("strong",[t._v("启动时时钟回拨")]),t._v("的检查。")])]),t._v(" "),_("p",{attrs:{align:"center"}},[_("img",{attrs:{src:t.$withBase("/assets/design/RedisMachineIdDistributor.png"),alt:"RedisMachineIdDistributor"}})]),t._v(" "),_("h4",{attrs:{id:"snowflakeid之时钟回拨问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#snowflakeid之时钟回拨问题"}},[t._v("#")]),t._v(" SnowflakeId之时钟回拨问题")]),t._v(" "),_("p",[t._v("时钟回拨的致命问题是会导致ID重复、冲突（这一点不难理解），ID重复显然是不能被容忍的。\n在"),_("strong",[t._v("SnowflakeId")]),t._v("算法中，按照"),_("strong",[t._v("MachineId")]),t._v("分区ID，我们不难理解的是不同"),_("strong",[t._v("MachineId")]),t._v("是不可能产生相同ID的。所以我们解决的时钟回拨问题是指当前"),_("strong",[t._v("MachineId")]),t._v("的时钟回拨问题，而不是所有集群节点的时钟回拨问题。")]),t._v(" "),_("p",[_("strong",[t._v("MachineId")]),t._v("时钟回拨问题大体可以分为俩种情况：")]),t._v(" "),_("ul",[_("li",[t._v("运行时时钟回拨：即在运行时获取的当前时间戳比上一次获取的时间戳小。这个场景的时钟回拨是很容易处理的，一般"),_("strong",[t._v("SnowflakeId")]),t._v("代码实现时都会存储"),_("code",[t._v("lastTimestamp")]),t._v("用于运行时时钟回拨的检查，并抛出时钟回拨异常。\n"),_("ul",[_("li",[t._v("时钟回拨时直接抛出异常是不太好地实践，因为下游使用方几乎没有其他处理方案（噢，我还能怎么办呢，等吧），时钟同步是唯一的选择，当只有一种选择时就不要再让用户选择了。")]),t._v(" "),_("li",[_("code",[t._v("ClockSyncSnowflakeId")]),t._v("是"),_("code",[t._v("SnowflakeId")]),t._v("的包装器，当发生时钟回拨时会使用"),_("code",[t._v("ClockBackwardsSynchronizer")]),t._v("主动等待时钟同步来重新生成ID，提供更加友好的使用体验。")])])]),t._v(" "),_("li",[t._v("启动时时钟回拨：即在启动服务实例时获取的当前时钟比上次关闭服务时小。此时的"),_("code",[t._v("lastTimestamp")]),t._v("是无法存储在进程内存中的。当获取的外部存储的"),_("strong",[t._v("机器状态")]),t._v("大于当前时钟时钟时，会使用"),_("code",[t._v("ClockBackwardsSynchronizer")]),t._v("主动同步时钟。\n"),_("ul",[_("li",[t._v("LocalMachineStateStorage：使用本地文件存储"),_("code",[t._v("MachineState")]),t._v("(机器号、最近一次时间戳)。因为使用的是本地文件所以只有当实例的部署环境是稳定的，"),_("code",[t._v("LocalMachineStateStorage")]),t._v("才适用。")]),t._v(" "),_("li",[t._v("RedisMachineIdDistributor：将"),_("code",[t._v("MachineState")]),t._v("存储在"),_("strong",[t._v("Redis")]),t._v("分布式缓存中，这样可以保证总是可以获取到上次服务实例停机时"),_("strong",[t._v("机器状态")]),t._v("。")])])])]),t._v(" "),_("h4",{attrs:{id:"snowflakeid之javascript数值溢出问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#snowflakeid之javascript数值溢出问题"}},[t._v("#")]),t._v(" SnowflakeId之JavaScript数值溢出问题")]),t._v(" "),_("p",[_("code",[t._v("JavaScript")]),t._v("的"),_("code",[t._v("Number.MAX_SAFE_INTEGER")]),t._v("只有53-bit，如果直接将63位的"),_("code",[t._v("SnowflakeId")]),t._v("返回给前端，那么会产生值溢出的情况（所以这里我们应该知道后端传给前端的"),_("code",[t._v("long")]),t._v("值溢出问题，"),_("strong",[t._v("迟早")]),t._v("会出现，只不过SnowflakeId出现得更快而已）。\n很显然溢出是不能被接受的，一般可以使用以下俩种处理方案：")]),t._v(" "),_("ul",[_("li",[t._v("将生成的63-bit"),_("code",[t._v("SnowflakeId")]),t._v("转换为"),_("code",[t._v("String")]),t._v("类型。\n"),_("ul",[_("li",[t._v("直接将"),_("code",[t._v("long")]),t._v("转换成"),_("code",[t._v("String")]),t._v("。")]),t._v(" "),_("li",[t._v("使用"),_("code",[t._v("SnowflakeFriendlyId")]),t._v("将"),_("code",[t._v("SnowflakeId")]),t._v("转换成比较友好的字符串表示："),_("code",[t._v("{timestamp}-{machineId}-{sequence} -> 20210623131730192-1-0")])])])]),t._v(" "),_("li",[t._v("自定义"),_("code",[t._v("SnowflakeId")]),t._v("位分配来缩短"),_("code",[t._v("SnowflakeId")]),t._v("的位数（53-bit）使 "),_("code",[t._v("ID")]),t._v(" 提供给前端时不溢出\n"),_("ul",[_("li",[t._v("使用"),_("code",[t._v("SafeJavaScriptSnowflakeId")]),t._v("("),_("code",[t._v("JavaScript")]),t._v(" 安全的 "),_("code",[t._v("SnowflakeId")]),t._v(")")])])])]),t._v(" "),_("h2",{attrs:{id:"号段模式-segmentid"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#号段模式-segmentid"}},[t._v("#")]),t._v(" 号段模式（SegmentId）")]),t._v(" "),_("p",{attrs:{align:"center"}},[_("img",{attrs:{src:t.$withBase("/assets/design/SegmentId.png"),alt:"SegmentId"}})]),t._v(" "),_("p",[t._v("从上面的设计图中，不难看出"),_("strong",[t._v("号段模式")]),t._v("基本设计思路是通过每次获取一定长度（Step）的可用ID（Id段/号段），来降低网络IO请求次数，提升性能。")]),t._v(" "),_("ul",[_("li",[t._v("👎强依赖第三方号段分发器，可用性受到第三方分发器影响。")]),t._v(" "),_("li",[t._v("👎每次号段用完时获取"),_("code",[t._v("NextMaxId")]),t._v("需要进行网络IO请求，此时的性能会比较低。")]),t._v(" "),_("li",[t._v("单实例ID单调递增，全局趋势递增。\n"),_("ul",[_("li",[t._v("从设计图中不难看出"),_("strong",[t._v("Instance 1")]),t._v("每次获取的"),_("code",[t._v("NextMaxId")]),t._v("，一定比上一次大，意味着下一次的号段一定比上一次大，所以从单实例上来看是单调递增的。")]),t._v(" "),_("li",[t._v("多实例各自持有的不同的号段，意味着同一时刻不同实例生成的ID是乱序的，但是整体趋势的递增的，所以全局趋势递增。")])])]),t._v(" "),_("li",[t._v("ID乱序程度受到Step长度以及集群规模影响（从趋势递增图中不难看出）。\n"),_("ul",[_("li",[t._v("假设集群中只有一个实例时"),_("strong",[t._v("号段模式")]),t._v("就是单调递增的。")]),t._v(" "),_("li",[_("code",[t._v("Step")]),t._v("越小，乱序程度越小。当"),_("code",[t._v("Step=1")]),t._v("时，将无限接近单调递增。需要注意的是这里是无限接近而非等于单调递增，具体原因你可以思考一下这样一个场景：\n"),_("ul",[_("li",[t._v("号段分发器T"),_("sub",[t._v("1")]),t._v("时刻给"),_("strong",[t._v("Instance 1")]),t._v("分发了"),_("code",[t._v("ID=1")]),t._v(",T"),_("sub",[t._v("2")]),t._v("时刻给"),_("strong",[t._v("Instance 2")]),t._v("分发了"),_("code",[t._v("ID=2")]),t._v("。因为机器性能、网络等原因，"),_("code",[t._v("Instance 2")]),t._v("网络IO写请求先于"),_("code",[t._v("Instance 1")]),t._v("到达。那么这个时候对于数据库来说，ID依然是乱序的。")])])])])])]),t._v(" "),_("h2",{attrs:{id:"号段链模式-segmentchainid"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#号段链模式-segmentchainid"}},[t._v("#")]),t._v(" 号段链模式（SegmentChainId）")]),t._v(" "),_("p",{attrs:{align:"center"}},[_("img",{attrs:{src:t.$withBase("/assets/design/SegmentChainId.png"),alt:"SegmentChainId"}})]),t._v(" "),_("p",[_("strong",[t._v("SegmentChainId")]),t._v("是"),_("strong",[t._v("SegmentId")]),t._v("增强版，相比于"),_("strong",[t._v("SegmentId")]),t._v("有以下优势：")]),t._v(" "),_("ul",[_("li",[t._v("稳定性："),_("strong",[t._v("SegmentId")]),t._v("的稳定性问题（P9999=46.624(us/op)）主要是因为号段用完之后同步进行"),_("code",[t._v("NextMaxId")]),t._v("的获取导致的（会产生网络IO）。\n"),_("ul",[_("li",[_("strong",[t._v("SegmentChainId")]),t._v(" （P9999=0.208(us/op)）引入了新的角色"),_("strong",[t._v("PrefetchWorker")]),t._v("用以维护和保证"),_("strong",[t._v("安全距离")]),t._v("，理想情况下使得获取ID的线程几乎完全不需要进行同步的等待"),_("code",[t._v("NextMaxId")]),t._v("获取，性能可达到近似 "),_("code",[t._v("AtomicLong")]),t._v(" 的 "),_("em",[t._v("TPS 性能:12743W+/s")]),t._v(" "),_("RouterLink",{attrs:{to:"/guide/perf-test.html"}},[t._v("JMH 基准测试")]),t._v(" 。")],1)])]),t._v(" "),_("li",[t._v("适应性：从"),_("strong",[t._v("SegmentId")]),t._v("介绍中我们知道了影响"),_("strong",[t._v("ID乱序")]),t._v("的因素有俩个：集群规模、"),_("code",[t._v("Step")]),t._v("大小。集群规模是我们不能控制的，但是"),_("code",[t._v("Step")]),t._v("是可以调节的。\n"),_("ul",[_("li",[_("code",[t._v("Step")]),t._v("应该近可能小才能使得"),_("strong",[t._v("ID单调递增")]),t._v("的可能性增大。")]),t._v(" "),_("li",[_("code",[t._v("Step")]),t._v("太小会影响吞吐量，那么我们如何合理设置"),_("code",[t._v("Step")]),t._v("呢？答案是我们无法准确预估所有时点的吞吐量需求，那么最好的办法是吞吐量需求高时，Step自动增大，吞吐量低时Step自动收缩。")]),t._v(" "),_("li",[_("strong",[t._v("SegmentChainId")]),t._v("引入了"),_("strong",[t._v("饥饿状态")]),t._v("的概念，"),_("strong",[t._v("PrefetchWorker")]),t._v("会根据"),_("strong",[t._v("饥饿状态")]),t._v("检测当前"),_("strong",[t._v("安全距离")]),t._v("是否需要膨胀或者收缩，以便获得吞吐量与有序性之间的权衡，这便是"),_("strong",[t._v("SegmentChainId")]),t._v("的自适应性。")])])])])])}),[],!1,null,null,null);e.default=a.exports}}]);